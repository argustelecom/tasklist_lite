### Слой представления 
Слой представления в терминах чистой архитектуры, см. https://devmuaz.medium.com/flutter-clean-architecture-series-part-1-d2d4c2e75c47
От содержимого этого package не должно зависеть ничего извне его
Он сам может зависеть от domain, core, conf
Состоит из:
-- pages -- описание страниц(еще их называют экранами в мобильной разработке) приложения. Задача page -- только описать дерево виджетов на странице, но не 
описывать логику представления (для этого есть контроллеры) и уж тем более не содержать shared state (для local state есть stateful виджеты, см. ниже)
-- dialogs -- диалоги, то есть просто модальные страницы. Вынесены в отдельный package из соображений удобства группировки. Поведение такое же, как у pages
-- widgets -- кирпичики, из которых состоят страницы и диалоги. Как правило, код обособляется в виджет, когда есть потребность его использовать в нескольких
местах в ui. А еще это полезно, потому что повышает структурируемость кода и его готовность к повторному использованию. Но требует дополнительных затрат на 
обобщение до виджета. 
-- state -- классы, описывающие состояние приложения. Не все состояние (пока) живет здесь. Здесь живет только та часть state, которая нуждается в restor`абельности.
Для этого все классы здесь являются потомками PersistentState. Та часть state, которая не нуждается в сохранении при f5(или при вытеснении приложения в фон), на 
данный момент живет в контроллерах (см. ниже)
-- controllers -- содержат как не-restorable state, так и логику представления. Например, если при выборе новой даты в календаре нужно перефильтровать список задач,
то ui слой(виджет календаря или страница, содержащая календарь) только вызывает контроллер (сеттер новой даты). Сеттер проводит нужные изменения в state (если дату
нужно хранить между нажатиями f5, то путем вызовов соответствующих сеттеров в persistent state, а иначе -- внутри самого контроллера) и все. Новые данные в ui 
появятся за счет того, что ui-слой смотрит на геттер в контроллере, который возвращает уже отфильтрованные задачи. Сам ui не занимается фильтрацией. Контроллер
тоже не перефильтровывает коллекцию задач, а лишь изменяет фильтры, по которым фильтруется список при его получении ui-слоем.
